# JAVA跨平台

```
// 编译 .java -> .class（字节码）
javac xxx.java

// 运行
java xxx

// 反编译 .class -> .java
javap -c xxx.class

// 口语化形式
javap -verbose xxx.class
```

- `*.java -> *.class -> JVM解析为机器码`

# JVM

## 架构

- class loader 加载`*.class`文件到内存
- runtime data area JVM内存结构模型
  - stack
  - heap
  - method area
  - pc register
  - native method stack
- execution engine 对命令进行解析
- native interface ~ native libraries，融合不同开发语言的原生库为Java所用

# 反射

> Java反射机制是在运行状态中，对于任何一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为Java的反射机制

# 类加载器

> 主要负责从系统外部获取Class二进制数据流，然后加载虚拟机进行连接初始化等操作

## 种类

- BootStrap ClassLoader：C++编写，加载核心库 `java.*`
- ExtClassLoader：Java编写，加载拓展库 `javax.*`，加载在`java.ext.dirs`属性里面的路径
- AppClassLoader：Java编写，加载程序所在目录，即`java.class.path`属性里面的路径
- CustomClassLoader：Java编写，个性化定制
  - 继承ClassLoader
  - `findClass`，根据名称或者位置去加载字节码，返回字节数组
  - `defineClass`，接受字节数组，解析定义字节流（调用父类方法即可），返回Class

## 双亲委派机制

> 目的是避免多份同样字节码的加载

- 自底向上检查类是否已经加载，自顶向下尝试加载类

## 类的装载过程

1. 加载：通过类加载器加载字节码，生成Class对象
2. 链接（resolve）
   1. 校验：检查加载的Class的正确性与安全性
   2. 准备：为类变量分配存储空间并设置类变量初始值
   3. 解析：JVM将常量池内的符号引用转换为直接引用（可选）

3. 初始化：执行类变量赋值和静态代码块

## 类的加载方式

> 隐式加载：new；显式加载：loadClass，forName调用newInstance方法创建实例

### 区别

- `Class.forName`得到的Class是已经初始化完成的
- `Classloader.loadClass`得到的Class是还没有链接的，可以加快资源加载速度。如SpringIOC中的资源加载获取资源时，如果以classpath方式加载，则使用loadClass方法，加快资源加载速度（lazyLoading延迟加载）

# 内存布局

## 内存地址

- **逻辑地址**通过**分段管理机制**转换为**线性地址**

- **线性地址**通过**分页管理机制**，或者直接转换为**物理地址**

## 空间划分

- 内核空间
- 用户空间

## JVM内存区域划分

### 线程私有

#### 程序计数器

- 当前线程所执行字节码的行号指示器（逻辑）
- 如果是Native方法，其值为Undefined
- 不会发生内存泄漏

#### 虚拟机栈

> Java方法执行的内存模型

- 局部变量表：包含方法执行过程中的所有变量
- 操作栈：类似于CPU寄存器，出入栈、复制、交换、产生消费变量（从局部变量表取数据），容量一般为2
- 动态连接
- 返回地址

- 栈帧（内存不需要GC回收）

#### 本地方法栈

### 线程共享

#### MetaSpace（方法区）

> 类加载信息 OOM，元空间；方法区的实现之一

- 元空间（MetaSpace）JDK8与永久代（PermGen）JDK7
  - 都是用来储存Class的信息如method与field
  - 元空间与永久代均是方法区的实现
  - 元空间使用本地内存（JVM启动时根据实际情况动态分配），永久代使用JVM内存
  - JDK7之后原先位于方法区的字符串常量池被移动到了堆中（原因：字符串常量池在永久代中，容易出现性能问题和内存溢出；类和方法的信息大小难以确定，给永久代的大小指定带来困难；永久代给GC带来了不必要的复杂度；方便HotSpot与其它JVM合并，因为永久代是HotSpot特有的）

#### 常量池

#### 堆

- JVM参数
  - `Xms`，初始的JAVA堆的大小 memory start
  - `Xmx`，堆能达到的最大值，memory max
  - `Xss`，每个线程虚拟机栈的大小 stack size

- 对象实例的分配对象
- 物理上可以不连续
- GC管理的主要区域

- 内存分配策略
  - 静态，编译时确定每个数据目标在运行时的存储空间需求
  - 栈式，数据区需求在编译时未知，运行时模块入口确定
  - 堆式，数据区与运行时模块入口均无法确定，动态分配

- 堆与栈
  - 引用对象、数组时，栈定义变量保存堆中目标的首地址
  - 栈自动释放内存，堆需要GC
  - 栈一般比堆小
  - 栈产生的碎片一般小于堆
  - 栈支持静态和动态分配，而堆仅仅支持动态分配
  - 栈的效率比堆高

## intern 方法

> 使用""的字面量在字符串常量池中创建，使用new String创建的字符串在堆中

- JDK6，如果字符串常量池先前已经创建该对象，则直接返回池中字符串的引用；否则将该对象拷贝到字符串常量池中并返回其引用（副本）
- JDK6+，如果字符串常量池先前已经创建该对象，则直接返回池中字符串的引用；如果存在堆中，则将堆中的字符串对象**引用**添加到常量池中，并返回该引用；否则创建对象添加到字符串常量池中并返回其引用

# 垃圾回收机制

## 标记算法

### 引用计数算法

- 通过判断对象得引用数量来决定对象是否可以被回收
- 每个实例都有一个引用计数器
- 引用计数为0的对象可以被当做垃圾
- 优点：效率高；缺点：无法检测到循环引用的情况导致内存泄漏

### 可达性分析算法

- 通过判断对象的引用链是否可达来决定对象是否可以被回收
- GC ROOTS（不止一个）作为起始点开始进行图的遍历，路径则称为引用链
- GC ROOT有哪些（都是对象）
  - 虚拟机栈中引用的对象（栈帧中的本地变量表）
  - 本地方法栈中JNI的引用对象
  - 方法区中常量引用的对象
  - 方法区中静态属性引用的对象
  - **活跃线程的引用对象**

## 回收算法

### 标记-清除算法

1. 标记：从GCROOTS进行扫描，对存活的对象进行标记
2. 清除：对堆内存从头到尾进行线性遍历，回收不可达对象，清除上一步做的标记

- 缺点：碎片化

### 复制算法

> **适用于对象存活率低的场景**，常用于年轻代

- 将可用空间分为对象面和空闲面
- 对象在对象面上创建
- GC时，存活的对象被从对象面复制到空闲面
- 将对象面一次性全部清除

### 标记-整理算法

> 标记-清除算法的改进，**避免了内存碎片化**，适合对象存活率高的场景（如老年代）

1. 标记：从GCROOTS进行扫描，对存活的对象进行标记
2. 清除：移动所有存活对象，且按照内存地址次序依次排列，然后将末端地址以后的内存全部回收

### 分代收集算法

> 垃圾回收算法的组合，按照对象生命周期的不同划分区域以采用不同的垃圾回收算法

- JDK6与JDK7
  -  新生代
  
  - 老年代

  - 永久代
  
- JDK8+
  -  新生代（复制算法），Minor GC 1/3
    
  - - Eden区（80%），伊甸园，对象的起源
    - 两个Survivor区（20%），from区（年龄为1），to区（年龄为2）（会相互转换）
    
  - 老年代（标记整理算法），Full GC，往往伴随着Minor GC 2/3 默认15岁，`MaxTenuringThreshold`参数配置
    - 长期存活至一定年龄的对象
    - Survivor区放不下的对象（分派担保）
    - 新生成的大对象，`PretenuerSizeThreshold`
    
  - `SurvivorRatio` Eden与Survivor的比值，默认8：1
  
  - `NewRatio`：老年代和新生代内存大小比例，默认1：2
  
- 触发Full GC的条件
  - 老年代空间不足
  - 永久代空间不足
  - CMS GC收集时出现 promotion failed、concurrent mode failure
  - Minor GC晋升到老年代的平均大小大于老年代剩余空间
  - 调用System.gc()
  - 使用RMI进行RPC或者管理的JDK应用，默认每小时进行一次Full GC

## 分代收集算法

### Stop The World

- JVM由于要执行GC而停止了应用程序的执行
- 任何一种GC算法中都会产生
- 多数GC优化通过减少STW发生的时间来提高程序性能

### SafePoint

- 分析过程中对象引用关系不会发生变化的时间点
- 产生安全点的地方：方法调用、循环跳转、异常跳转

## 垃圾收集器

- JVM运行模式：Server与Client；Server启动慢但是后期性能好，优化多，`java -version`查看模式

- ![GCCollector](.\GCCollector.png)

### 新生代收集器

> 都是复制算法
>
> Parallel 收集器系列、G1收集器都是独立实现，对其他收集器兼容性不太好

1. Serial收集器（Serial，串行）
   1. `-XX:+UseSerialGC`
   2. 复制算法
   3. 单线程收集，GC时暂停所有工作线程
   4. 简单高效，Client模式下默认新生代收集器
2. ParNew收集器
   1. `-XX:+UseParNewGC`
   2. 复制算法
   3. 多线程收集，其余的和Serial收集器一致
   4. Server模式首选新生代收集器
3. Parallel Scavenge（并发清除）
   1. `-XX:+UseParallelGC`
   2. 复制算法
   3. 多线程收集，但是更关注吞吐量（运行用户代码时间/(运行用户代码时间+垃圾收集时间)）
   4. Server默认新生代收集器
4. `-XX:+UseAdaptiveSizePolicy`将内存调优任务交予OS

### 老年代收集器

1. Serial Old
   1. `-XX:+UseSerialOldGC`
   2. 标记整理算法
   3. 单线程
   4. Client模式下默认的老年代收集器
2. Parallel Old
   1. `-XX:+UseParallelOldGC`
   2. 标志整理算法
3. CMS收集器
   1. `-XX:+UseConcMarkSweepGC`
   2. **标记-清除算法**
   3. 适合存在大量存活时间长的对象
   4. GC流程
      1. 初始标记：stop the world（初始化）
      2. 并发标记：并发追溯标记，程序不停顿
      3. 并发预清理：查找并发标记阶段从年轻代晋升老年代的对象
      4. 出现标记：暂停虚拟机，扫描CMS堆中剩余对象
      5. 并发清理：多线程清理垃圾对象
      6. 并发重置：重置CMS数据结构

### 混合收集器

1. G1收集器 Garbage First
   1. `-XX:+UseG1GC`
   2. 复制+标记-整理算法
   3. 特点
      1. 并行和并发
      2. 分代收集
      3. 空间整合
      4. 可预测的停顿
      5. 将整个堆内存划分为多个等大小的Region
      6. 新生代与老年代不再物理隔离

## finalize

- 与C++的析构函数不同，析构函数调用确定，但是finalize方法调用不确定，随时有可能被终止
- 当垃圾回收器宣布一个对象死亡时，至少需要经过两次的标记过程。如果对象被发现没有和GCROOT的引用链，则会被第一次标记。如果该对象实现了finalize方法且未被引用过，会被放置于`F-Queue`队列中。后续一个低优先级的finalize线程会调用这个队列里面对象的finalize方法
- 给予对象最后一次逃逸机会（在finalize中引用自己）

## 引用的分类

### 强引用

- new关键字创建对象的引用
- 遇到内存不足的情况，JVM抛出异常也不会回收具有强引用的对象
- 通过将对象设置为null来弱化引用，**加快**其回收

### 软引用

- 可以实现高速缓存

- 对象处在有用但是非必须的状态

- 只有当内存不足时，GC会回收弱引用对象的内存

  ```
  String str = new String("abc");  // 强引用
  
  SoftReference<String> softRef = new SoftReference(str); // 软引用
  ```

### 弱引用

- 非必须的对象

- GC时会被回收

- 适用于引用偶尔被使用且不影响垃圾收集的对象

  ```
  String str = new String("abc");  // 强引用
  
  WeakReference<String> weakRef = new WeakReference(str); // 弱引用
  ```

### 虚引用

- 不会决定对象的生命周期

- 任何时候都有可能被垃圾收集器回收

- 用来跟踪对象被垃圾收集器回收的活动，起哨兵作用

- 必须和引用队列ReferenceQueue搭配使用

  ```
  String str = new String("abc");  // 强引用
  
  ReferenceQueue queue = new ReferenceQueue();
  
  PhantomReference ref = new PhantomReference(str,queue);
  ```

### 引用队列

- 无实际储存结构，储存逻辑依赖内部节点之间的关系来表达
- 储存关联的且被GC的软引用、若引用以及虚引用