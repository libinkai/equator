# 参考

- 周志明《深入理解Java虚拟机》
- https://blog.csdn.net/xyh930929/article/details/84067186

# Java内存模型（JMM）

## 运行时数据区

![M](W:\leaning\学习笔记\进阶\JVM\JMM.png)

### 程序计数器

- 在一个确定的时刻，一个处理器只能执行一条线程中的指令。当由于当前线程分配的时间片用完或者其它情况导致线程被切换时，当前线程的现场需要被保留。当该线程重新执行时，会根据程序计数器来恢复到正确的执行位置
- 程序计数器是Java虚拟机规范中唯一一个没有任何OutOfMemoryError的区域

### Java虚拟机栈

#### 栈帧（Stack Frame）

> 每个Java方法在执行时，都会创建一个栈帧（Stack Frame）

##### 栈帧存储的内容

- 局部变量表（基本数据类型、对象引用类型）
- 操作数栈（ Java 字节码指令的操作数存放在操作数栈中，当执行某条带 n 个操作数的指令时，就从栈顶取 n 个操作数，然后把指令的计算结果入栈。因此，当我们说 JVM 执行引擎是基于栈的时候，其中的“栈“指的就是操作数栈）
- 动态链接（每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态链接）
- 方法出口（当一个方法开始执行后，只有两种方式可以退出：一种是遇到方法返回的字节码指令；一种是遇见异常，并且这个异常没有在方法体内得到处理。无论采用何种退出方式，在方法退出之后，都需要返回到方法被调用的位置，程序才能继续执行）


#### 异常情况

- StackOverFlowError：线程请求的栈深度大于虚拟机允许的深度
- OutOfMemoryError：虚拟机栈动态拓展时无法申请到足够的内存

### 本地方法栈

> 和Java虚拟机栈情况基本一致

### Java堆



### 方法区



