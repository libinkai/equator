> 参考资料：《深入理解Java虚拟机》
>
> 用于快速回忆，详情请看书籍原文

# GC需要关注的三个问题

1. 哪些内存需要回收 What
2. 什么时候回收 When
3. 如何回收 How

# What

- 在JVM的内存区域划分中，程序计数器、虚拟机栈、本地方法栈是线程私有的，它们的生命周期与线程保持一致，其内存分配和回收都具备确定性
- Java堆与方法区是线程共享的，其内存分配与回收都是动态的，GC关注的内存区域就是这些区域

## 堆的GC

### 判断对象是否存活

- 引用计数算法：循环引用会导致内存泄漏
- 可达性分析算法：由GCROOTS出发遍历引用路径
  - GCROOTS
    - 虚拟机栈中引用的对象
    - 本地方法栈中引用的对象
    - 方法区中静态属性引用的对象
    - 方法区中常量引用的对象

## 方法区的GC

- 常量的GC：其它地方没有引用该字面量
- 类的GC：
  - 该类的所有实例对象均已被回收
  - 加载该类的类加载器已被回收
  - 该类对应的Class对象没有在任何地方被引用

# When

- 程序调用`System.gc()`时可以触发（会建议JVM进行垃圾回收，不代表一定会进行GC）

- 系统自身来决定GC触发的时机

# How

## GC算法

- 标记-清除算法
- 复制算法
- 标记-整理算法
- **分代收集算法**

# 垃圾收集器

## 新生代收集器

> 都是复制算法
>
> Parallel 收集器系列、G1收集器都是独立实现，对其他收集器兼容性不太好

1. Serial收集器（Serial，串行）
   1. 复制算法
   2. 单线程收集，GC时暂停所有工作线程
   3. 简单高效，Client模式下默认新生代收集器

2. Parallel Scavenge（并发清除）
   1. 复制算法
   2. 多线程收集，但是更关注**吞吐量**（吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)）
   3. Server默认新生代收集器
3. ParNew收集器
   1. 复制算法
   2. 多线程收集，其余的和Serial收集器一致
   3. Server模式首选新生代收集器

## 老年代收集器

1. Serial Old
   1. 标记-整理算法
   2. 单线程
   3. Client模式下默认的老年代收集器
2. Parallel Old
   1. 标志-整理算法
   2. 多线程
3. CMS收集器（Concurrent Mark Sweep）
   1. **标记-清除算法**
   2. 适合存在大量存活时间长的对象
   3. GC流程
      1. 初始标记：stop the world（初始化）
      2. 并发标记：并发追溯标记，程序不停顿
      3. 并发预清理：查找并发标记阶段从年轻代晋升老年代的对象
      4. 出现标记：暂停虚拟机，扫描CMS堆中剩余对象
      5. 并发清理：多线程清理垃圾对象
      6. 并发重置：重置CMS数据结构

## 通用收集器 G1收集器

- 标记-整理算法+复制算法
- 多线程
- 分代收集