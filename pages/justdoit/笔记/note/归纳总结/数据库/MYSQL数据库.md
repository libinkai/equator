# 架构

- 储存（文件系统）
- 程序实例
  - 存储管理
  - 缓存机制
  - SQL解析
  - 日志管理
  - 权限划分
  - 容灾管理
  - 索引管理
  - 锁管理

# 索引

## 数据结构

### 二叉搜索树

- 二分查找
- 即使可以通过旋转使得树变得平衡，但是旋转造成太多的IO操作，影响性能（每个节点储存数量太少）

### B树

> 平衡多路查找树

- 定义
  - 根节点至少包含两个孩子
  - 树中每个节点最多包含m个孩子（m>=2）
  - 除了根节点和叶子节点之外，其它每个节点至少有ceil(m/2)个孩子（ceil取上限）
  - 所有叶子节点位于同一层（各子树高度一样）
  - 假设每个非终端节点中包含n个关键字信息，其中
    - `Ki(i=1~n)`为关键字，且关键字按照顺序升序排序
    - 关键字n个数须满足：`[ceil(m/2)-1]<=n<=m-1`，即比孩子数上限少一个，除了根节点和叶子节点之外的节点的n，比它指向孩子的指针个数少一个
    - 关键字对应的子树，满足递增关系

### B+树

> B树的变体

- 与B树的区别
  - 非叶子节点的子树指针与关键字个相同
  - 非叶子节点的子树指针Pi，指向关键字值`[K[i],K[i+1)]`的子树
  - 非叶子节点引用来索引，数据均保存在叶子节点中
  - 所有叶子节点都有指针指向下一个叶子节点，并且按照升序排序
- 优势
  - B+树的磁盘读写代价低
  - B+树查找效率更稳定（每次从根节点到叶子节点）
  - B+树更有利于对数据库的扫描（遍历叶子节点链表）

### 哈希

- 只适合等值索引，不能使用范围查询
- 无法用来避免数据的排序操作
- 不能利用部分索引键查询
- 不能避免表扫描
- 数据量过大时性能下降（哈希碰撞）

### BitMap位图索引

> 适合数据统计需求大，并发低的场景，很少数据库支持

## 密集索引和稀疏索引

- 密集索引文件中的每个搜索码值都对应一个索引值（一个索引项对应一行数据记录）
- 稀疏索引文件只为索引码的某些值建立索引项（一个索引项对应一些数据记录）

### InnoDB（聚簇）

- 若一个主键被定义，该主键则作为密集索引
- 若没有主键，则该表的第一个唯一非空索引则作为密集索引
- 若不满足以上条件，InnoDB内部会生成一个隐藏主键作为密集索引
- 非主键索引储存相关键位和其对应的主键值，包含两次查找（回表）

### MyISAM（非聚簇）

- 数据记录独立储存
- 主键索引与辅助索引地位平等

### 物理文件

- `.frm`文件储存表结构
- InnoDB
  - `.ibd`文件，数据与索引
- MyISAM
  - `.MYI` 索引
  - `.MYD` 数据

## 联合索引最左匹配原则

- MYSQL会一直向右匹配SQL语句直到遇到范围查询（<、>、between、like），如`(a,b,c,d)`联合索引，SQL语句`where a = 3 and b=4 and c > 5 and d = 6`则d无法用到索引。`(a,b,d,c)`联合索引则可以，`abc`可以乱序
- `=`与`in`可以乱序，查询优化器会优化

## 索引不是越多越好

- 数据量太小的表，不需要索引
- 数据变化需要维护索引，更多的索引意味着更多的成本
- 更多的索引意味着更多的存储空间

# 锁

## MyISAM与InnoDB的锁

- MyISAM只支持表级锁
- InnoDB即支持表级锁也支持行级锁

## 表锁

```
lock tables xxx_table read | write; // 添加读锁（共享锁）|写锁（排他锁）

unlock tables; // 取消锁
```

- MyISAM在执行select语句时，自动加读锁；执行insert、delete、update语句时加写锁。当一个表没有读锁的时候，才可以加上写锁;当一个表上没有写锁的时候，才可以加上写锁或者写锁
- 让select语句加排他锁：在语句后面加上`for update`

## 行锁

```
show variables like 'autocommit'; // 自动提交，默认为ON

begin transaction //显式启动事务，与autocommit=OFF等效

mysql的二段锁协议：按需加锁、提交（commit）时统一释放锁

// InnoDB对select做了优化，不加读锁
在select语句加读锁：在语句之后加lock in share mode

InnoDB中对同一行加读锁，读锁兼容

InnoDB在没有用到索引的时候，会使用表级锁；反之，会使用行级锁和Gap锁

InnoDB还支持表级锁意向锁：IS与IX
```

## MyISAM与InnoDB场景

> InnoDB需要回表，消耗比MyISAM大

- MyISAM
  - 频繁执行全表count语句
  - 对数据进行增删改的频率不高，查询非常高
  - 没有事务

- InnoDB
  - 适合增删改查都频繁的场景
  - 需要支持事务

## 数据库锁的分类

- 按粒度：表级锁、行级锁、页级锁（BDB）
- 锁级别：共享锁、排他锁
- 加锁方式：自动锁、表级锁
- 操作划分：DML锁，DDL锁
- 使用方式：乐观锁（在数据提交更新的时候再去检测是否冲突，实现方式有版本号/时间戳，需要在表中加version字段，类似于CAS）、悲观锁

## 事务四大特性

- A 原子性 Atomic
- C 一致性 Consistency（守恒）
- I **隔离性** Isolation
- D 持久性 Durability （恢复与容灾）

## 事务隔离级别

- 查看事务隔离级别`select @@tx_isolation`
- 设置隔离级别`set session transaction isolation level read uncommitted`
- `read uncommitted` 读未提交
- `read committed` 读已提交，Oracle默认
- `repeatable read` 可重复读，InnoDB默认，查询时数据不变，更新时用的是实际上的数据
- `Serializable` 序列化，串行化，最高级别

## 各级别下并发访问的问题

- 更新丢失：MYSQL所有事务隔离级别均可避免
- 脏读：READ-COMMIT级别以上可以避免
- 不可重复读：REPEATABLE-READ级别以上可以避免
- 幻读：更新的数据行比预期的多或者少，SERIALIZABLE级别可以避免（实际上InnoDB在RR级别即可避免）

## 当前读

> 增删改查无论是共享锁还是排他锁，均为当前读：读取的是记录的最新版本，并且读取之后，需要保证其它并发事务不能修改当前记录，需要加锁

- 当前读：
  - `select ... lock in share mode`（共享锁）
  - `select ... for update`（排他锁）
  - `update`、`delete`、`insert`（排他锁）

## 快照读

- 在隔离级别不在Serializable的前提下，不加锁的非阻塞读（普通读）
- 目的是提高并发度，基于多版本并发控制MVCC

- RC、RR级别下InnoDB非阻塞读如何实现
  - 数据行里面有`DB_TRX_ID`（最近一次修改本行事务的ID）、`DB_ROLL_PTR`（回滚指针）、`DB_ROW_ID`（无主键情况下，InnoDB创建的隐藏递增主键）字段
  - undo日志（insert、delete、update）
  - read view 视图

## InnoDB在RR级别下如何避免幻读

> 表象：快照读（非阻塞读）--伪MVCC；内在next-key锁（行锁+gap锁）

## Gap锁

- 间隙锁，锁住一定范围但是不包括数据本身，防止同一个事务的两次当前读出现幻读的情况
- RR及Serializable下支持Gap锁
- 应用场景
  - Gap锁主要用在非唯一索引或者不走索引的当前读中
  - 如果where条件全部命中，则不会使用Gap锁，只添加记录锁
  - 如果where条件部分命中或者全部不命中，则会使用Gap锁

# 语法

## GROUP BY

- 单表查询中，SELECT子句中的列必须为分组列或者列函数（不然对应不上）
- 列函数对于GROUP BY子句定义的每个组各返回一个结果

## HAVING

- 通常与GROUP BY子句一起使用（如果省略了GROUP BY子句，其与WHERE等效）
- WHERE过滤行，HAVING过滤列
- 出现在同一SQL中的顺序：WHERE>GROUP BY>HAVING

# 理论范式

