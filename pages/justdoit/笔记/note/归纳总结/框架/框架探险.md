# Servlet的弊端

- 一个Servlet最多可以接受4种请求方法，对应`get`、`post`、`put`、`delete`方法。随着业务的增长，Servlet会越来越多，我们希望将同一类Servlet合并到一个类中，即`Controller`，一个`Controller`可以包含多个`Action`

# 代理模式

- **无论是什么类型的代理模式，都需要两个东西：目标对象，代理对象**

## 静态代理

> - 静态代理一般一个代理对象只代理一个目标对象

## 动态代理

- 动态代理事先不知道要代理的是什么，只有在运行的时候才能确定
- Java动态代理只能代理接口，要代理类需要使用第三方的CLIGB等类

### JDK动态代理

- JDK动态代理类通常代理接口下的所有类
- JDK动态代理的代理类必须事先InvocationHandler接口，及使用Proxy类中的newProxyInstance方法动态的创建代理类

#### 代理类

```java
public class DynamicProxy implements InvocationHandler {
    // 目标对象
    private Object target;

    public DynamicProxy(Object target) {
        this.target = target;
    }

    /**
     * 定义代理的逻辑（invoke 方法不需要自己调用）
     * @param proxy
     * @param method
     * @param args
     * @return
     * @throws Throwable
     */
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        before();
        Object result = method.invoke(target, args);
        after();
        return result;
    }

    /**
     * 动态创建一个代理对象
     * @param <T>
     * @return
     */
    @SuppressWarnings("unchecked")
    public <T> T getProxy() {
        // 类加载器 类的接口 代理类（实现了InvocationHandler接口）
        return (T) Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this);
    }

    private void before() {
        System.out.println("打开冰箱门");
    }

    private void after() {
        System.out.println("关闭冰箱门");
    }
}
```

#### demo

```java
public class Demo {
    public static void main(String[] args) {
        ElephantActionImpl elephantAction = new ElephantActionImpl();
        DynamicProxy elephantDynamicProxy = new DynamicProxy(elephantAction);
        ElephantAction elephantActionProxy = elephantDynamicProxy.getProxy();
        elephantActionProxy.action();
        System.out.println("-----------------");

        DesireAction desireAction = new DesireActionImpl();
        DynamicProxy desireDynamicProxy = new DynamicProxy(desireAction);
        DesireAction desireActionProxy = desireDynamicProxy.getProxy();
        desireActionProxy.action();
        System.out.println("-----------------");
    }
}
```

### CGLIB动态代理

- CGLIB动态代理必须实现MethodInterceptor接口

#### 目标对象

````
public class PrideAction {
    public void action() {
        System.out.println("把骄傲关进冰箱");
    }
}
````

#### 代理类

````java
public class DynamicProxy implements MethodInterceptor {
    // 目标对象
    Object target;

    public DynamicProxy(Object target) {
        this.target = target;
    }

    @Override
    public Object intercept(Object targetObject, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
        before();
        // Object result = methodProxy.invoke(o, objects);
        // Object result = method.invoke(o, objects);
        Object result = methodProxy.invokeSuper(targetObject, objects);
        after();
        return result;
    }

    /**
     * 创建代理类
     * @param <T>
     * @return
     */
    @SuppressWarnings("unchecked")
    public <T> T getProxy() {
        // 目标类 代理类（实现了MethodInterceptor接口，即间接继承了Callable接口）
        return (T) Enhancer.create(target.getClass(), this);
    }

    private void before() {
        System.out.println("打开冰箱门");
    }

    private void after() {
        System.out.println("关闭冰箱门");
    }
}
````

#### demo

```java
public class Demo {
    public static void main(String[] args) {
        PrideAction prideAction = new PrideAction();
        DynamicProxy dynamicProxy = new DynamicProxy(prideAction);
        PrideAction proxy = dynamicProxy.getProxy();
        proxy.action();
    }
}
```

# IOC

# AOP

> 对方法的增强叫“织入”，对类的增强叫“引入”

## 术语

- Target
- Proxy
- JointPoint
- PointCut
- Advice
- Advisor
- Weaing
- Introduction

## Advise

### 前置增强

- 实现Spring的MethodBeforeAdvice接口

### 后置增强

### 返回后增强

### 环绕增强

- 实现AOP联盟的MethodInterceptor接口

### 抛出增强

- 实现Spring的ThrowsAdvice接口

### 引入增强

- 实现Spring的DelegationIntroductionInterceptor接口

## Advisor

> Advisor，切面；封装了Advice增强以及Pointcut切点

# MVC