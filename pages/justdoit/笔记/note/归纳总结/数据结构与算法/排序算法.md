# 基本概念

## 内部排序与外部排序

## 稳定性

## 分类

![排序算法分类](.\排序算法分类.png)

## 时空复杂度

![排序时间复杂度](.\排序时间复杂度.png)

# 计数排序

> 利用数组下标来确定元素的正确位置而不是基于元素的比较
>
> 计数，即统计待排序数组中各个元素出现的个数

## 空间优化

- 以`数组的最大值与最小值之差+1`作为统计数组的长度而不是`0~数组最大值`
- 将数组的最小值作为偏移量实现元素的映射

## 稳定性优化

- 统计数组从第二个元素开始，每个元素都加上前面所有元素之和，让统计数组存储的元素值，等于相应整数的最终排序位置

## 缺点

- 当数组最大值与最小值之差过大时，并不适合使用计数排序
- 当数组元素不是整数时，不适合使用计数排序

# 桶排序

> 解决计数排序无法对非整数元素排序的问题
>
> 桶排序不完全基于比较，但是桶内排序时，还是依赖了比较排序的

## 步骤

1. 创建一系列桶，确定每一个桶的区间范围
2. 遍历原始数组，将元素放入对应的桶
3. 桶内元素分别排序
4. 遍历桶，输出元素

## 缺点

- 如果桶内元素发布不均匀，会创建很多空桶，时间复杂度也将退化为`O(nlogn)`

# 基数排序

> 把排序工作拆分成多个阶段，每一个阶段只根据一位数（一个字符）进行计数排序，一共排序k轮
>
> 基数排序中使用了计数排序计数

## 细节

- 使用基数排序对字符串排序时，短的字符串使用`0`补全，将其当做是比`a`更小的字符