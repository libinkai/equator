# 单一职责原则

- 定义：应该有且仅有一个原因引起类的变更
- 适用对象
  - 接口
  - 类
  - 方法
- 最佳实践：接口一定要做到单一职责，类的设计尽量做到只有一个
  原因引起变化

# 里氏替换原则

> 采用里氏替换原则的目的就是增强程序的健壮性，版本升级时也可以保持非常好的兼容性。即使增加子类，原有的子类还可以继续运行。在实际项目中，每个子类对应不同的业务含义，使用父类作为参数，传递不同的子类完成不同的业务逻辑

- 重载与覆写
  - 覆写 Override，常发生在继承、实现关系中，函数签名完全一致
  - 重载 Overload，不一定发生在父子继承关系中，函数签名不一致（函数名相同，参数不同）

- 定义
  - 如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型S是类型T的子类型
  - 即所有引用基类的地方必须能透明地使用其子类的对象
- 通俗点讲，只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者可能根本就不需要知道是父类还是子类。但是，反过来就不行了，有子类出现的地方，父类未必就能适应
- 在类中调用其他类时务必要使用父类或接口，如果不能使用父类或接口，则说明类的设计已经违背了LSP原则
- 如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中已经发生“畸变”，则建议断开父子继承关系，采用依赖、聚集、组合等关系代替继承
- 规则
  - 子类必须完全实现父类的方法（不能是空方法，面向接口编程时的需要）
  - 子类可以有自己的个性（LSP可以正着用，反之不能）
  - 覆盖或实现父类的方法时输入参数可以被放大（子类的输入参数类型的范围扩大了，子类代替父类传递
    到调用者中，子类的方法永远都不会被执行）
  - 覆写或实现父类的方法时输出结果可以被缩小（父类的一个方法的返回值是一个类型T，子类的相同方法（重载或覆写）的返回值为S，那么里氏替换原则就要求S必须小于等于T，也就是说，要么S和T是同一
    个类型，要么S是T的子类）

# 依赖倒置原则

> 即面向接口编程

- 定义
  - 高层模块不应该依赖低层模块，两者都应该依赖其抽象
  - 抽象不应该依赖细节
  - 细节应该依赖抽象

- 在Java语言中，抽象就是指接口或抽象类，两者都是不能直接被实例化的；细节就是实现类，实现接口或继承抽象类而产生的类就是细节，其特点就是可以直接被实例化，也就是可以加上一个关键字new产生一个对象

# 接口隔离原则

- 定义
  - 客户端不应该依赖它不需要的接口
  - 类间的依赖关系应该建立在最小的接口上

# 迪米特法则

> 最少知识原则

- 定义

  一个对象应该对其他对象有最少的了解。通俗地讲，一个类应该对自己需要耦合或调用的类知道得最少

- 朋友类的定义是这样的：出现在成员变量、方法的输入输出参数中的类称为成员朋友类，而出现在方法体内
  部的类不属于朋友类，迪米特法则告诉我们一个类应该只和朋友类交流，

# 开闭原则

- 一个软件实体如类、模块和函数应该对扩展开放，对修改关闭即一个软件实体应该通过扩展来实现变化，而不是通过修改已有的代码来实现变化