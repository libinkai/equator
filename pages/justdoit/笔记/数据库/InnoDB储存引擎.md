# MYSQL

## 连接

> Unix域套接字只能用于在同一个计算机的进程间进行通信。虽然网络套接字也可以用于单机进程间的通信，但是使用Unix域套接字效率会更高，因为Unix域套接字仅仅进行数据复制，不会执行在网络协议栈中需要处理的添加、删除报文头、计算校验和、计算报文顺序等复杂操作，因而在单机的进程间通信中，更加推荐使用Unix域套接字

- TCP/IP：`mysql -h ip -u root -p123456`
- 命名管道、共享内存：Windows
- UNIX域套接字：Linux、Unix（套接字有网络套接字与域套接字之分）

# InnoDB

- 储存引擎时基于表的，而不是基于数据库的

## 体系结构

### 后台线程

- Master Thread，主要负责将缓冲池中的数据异步刷新到磁盘，保证数据一致性，包括合并插入缓冲、~~脏页的刷新~~、~~undo页回收~~
- IO Thread，主要有write、read、insert、log IO thread 四种，负责处理IO请求
- Purge Thread，负责undo页回收
- Page Cleaner Thread，负责脏页刷新

### 内存

#### 缓冲池

- 缓冲池，一块内存区域用来弥补磁盘速度问题。在数据库读取页后，将读取的页`FIX`在缓冲池中；下次读取相同页的时候，如命中则直接读取缓冲池的页，否则读取磁盘数据页。在修改页时，首先修改缓冲池的页，缓冲池的页通过checkpoint技术刷新到磁盘

- 缓冲池的三种页
  - free page：从未用过的页
  - clean page：干净的页，数据页的数据和磁盘一致
  - dirty page：脏页（被修改过的clean page）
- 缓冲池的三种链
  - free list：将free数据页使用链表链起来
  - LRU list：根据冷热将clean、dirty链起来
  - flush list：将页按照最早脏时间链起来

- 缓冲池的数据类型有：索引页、数据页、undo页、插入缓冲、数据字典等
- 缓冲池的淘汰策略为优化后的LRU算法即`midpoint`技术，新读取的页不是直接放到队首而是放在midpoint处，避免热点数据被淘汰。`innodb_old_blocks_time`参数控制页读取到midpoint之后需要等待多久之后被加入到LRU队列热端
  1. 3/8的list信息是作为old list，这些信息是被驱逐的对象
  2. list的中点就是我们所谓的old list头部和new list尾部的连接点，相当于一个界限
  3. 新数据的读入首先会插入到old list的头部
  4. 如果是old list的数据被访问到了，这个页信息就会变成new list，变成young page，就会将数据页信息移动到new sublist的头部
  5. 在数据库的buffer pool里面，不管是new sublist还是old sublist的数据如果不会被访问到，最后都会被移动到list的尾部作为牺牲者
- 脏页既存在LRU list中，也存在flush list中，前者用来管理缓冲池中页的可用性，后者用来管理将脏页刷新到磁盘

#### 重做日志缓冲

- InnoDB首先将缓冲日志刷新到日志文件，然后按照某种策略刷新到重做日志文件
- 通常情况下，重做日志缓冲不需要太大的空间，其刷新到文件的策略如下：
  - Master Thread每秒刷新一次
  - 每个事务提交时将重做日志刷新到日志文件中
  - 当重做日志缓冲剩余空间少于1/2时

#### 额外的内存池

- 每个缓冲池的帧缓冲，缓冲控制对象，这些对象的内存从额外内存池中申请

### Check Point技术

- 如果每次数据修改都刷脏页，会导致性能问题；此外，如果在刷脏页的时候数据库宕机了，数据就会丢失。为了避免数据丢失，数据库普遍采用了Write Ahead Log策略，即提交事务时，先写日志，再修改页

## 关键特性

### Insert Buffer

- B+树决定了非聚簇索引插入的离散性导致菲主键索引插入性能问题
- 使用Insert Buffer，对于非聚簇索引的插入或者更新操作，先判断非聚簇索引页是否在缓冲池中，如果不在，先放入Insert Buffer，然后按照一定的频率进行Insert Buffer与辅助索引页子节点的merge操作（合并），这通常能将多个插入合并到一个操作中（因为在同一个索引页面），提高了非聚簇索引插入的性能
- Insert Buffer使用场景：非唯一的辅助索引

### Change Buffer

## 两次写

