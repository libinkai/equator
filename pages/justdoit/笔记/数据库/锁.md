- `InnoDB储存引擎`不需要锁升级，因为其实现一个锁和多个锁的开销是相同的。其不是根据每个记录来产生行锁的，而是根据每个事务访问的每个页对锁采用位图的形式进行管理
- InnoDB行锁是通过给索引上的索引项加锁来实现的，只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁。由于MySQL的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然是访问不同行的记录，但是如果是使用相同的索引键，是会出现锁冲突的。
- latch与lock
  - latch一般称为闩门，用来锁住线程，无死锁机制
  - lock的对象是事务，用来锁定数据库中的对象，即行、页、表，有死锁机制
  - latch存在每个内存对象的数据结构中，lock存在于Lock Manager的哈希表中
- Page是Innodb存储的最基本结构，也是Innodb磁盘管理的最小单位，与数据库相关的所有内容都存储在Page结构里。Page分为几种类型：`数据页（B-Tree Node）`，`Undo页（Undo Log Page）`，`系统页（System Page）`，`事务数据页（Transaction System Page）`等；每个数据页的大小为`16kb`，每个Page使用一个32位（一位表示的就是0或1）的int值来表示，正好对应Innodb最大64TB的存储容量(16kb * 2^32=64tib)

# 锁的类型

## 行锁

- 共享锁 S
- 排他锁 X

## 意向锁

> 意向锁是将锁定的对象分为多个层次，意向锁意味着事务希望在更细粒度上进行加锁（一种不与行锁冲突的表级别的锁）

- 意向读锁 IS，事务想要获取一张表中某几行的共享锁
- 意向写锁 IX，事务想要获取一张表中某几行的排他锁
- 意向锁是有数据引擎自己维护的，用户无法手动操作意向锁。在为数据行加共享 / 排他锁之前，`InooDB `会先获取该数据行所在在数据表的对应意向锁
- 意向锁之间相互兼容，但是只有IS与S兼容，其它意向锁均与S、X互斥

- 意义：如果另一个任务试图在该表级别上应用共享或排它锁，则受到由第一个任务控制的表级别意向锁的阻塞。第二个任务在锁定该表前不必检查各个页或行锁，而只需检查表上的意向锁
- **意向锁并不会影响到多个事务对不同数据行加排他锁时的并发性**，即意向锁不影响行锁，这是与普通表锁的区别

## 一致性非锁定读

> 如果读取的行正在执行DELETE或者UPDATE操作，这时的读取操作不会因此去等待行上锁的释放而是去读取一个快照数据（MVCC）

- RC隔离级别下，一致性非锁定读总是获取被锁定行的最新一份快照数据？
- RR隔离级别下，一致性非锁定读总是获取事务开始时的行版本数据

## 一致性锁定读（当前读）

```
select ... for update // （对行记录）加X锁

select ... lock in share mode // （对行记录）加S锁

// 使用以上语句，需要开启事务
```

## 自增长锁

## 外键锁

- 对于外键值的插入，需要以`select ...lock in share mode`的方式查询父表

## 悲观锁与乐观锁

- 悲观锁
- 乐观锁：使用版本号实现，读取时读取版本号字段，写入时判断版本号是否已经改变

# 锁的算法

> InnoDB默认隔离级别为RR，RR使用NKL，而RC使用RL

## Record Lock

> 单行记录上的锁

- Record Lock 总是会锁住索引记录，如果`InnoDB引擎`表没有设置索引，引擎会锁定隐式的主键
- 聚簇索引

## Gap Lock

> 间隙锁，锁定一个范围，但是不包含记录本身

- 防止幻读

## Next-Key Lock

> Record Lock + Gap Lock，锁定一个范围并锁定本身

- 左开右闭区间
- 当索引具有唯一属性时，NKL会退化为RL
- 辅助索引
- 在`InnoDB储存引擎`中，对于insert操作，其会检查插入记录的下一条记录是否被锁定，若被锁定，则不允许查询

# 锁导致的问题

## 更新丢失

- 一个事务的更新被另外一个事务的更新覆盖。所有数据库在数据库层面上均解决了更新丢失问题（select加X锁）

## 脏读

- 脏数据：事务对缓冲池中行修改而且还没有提交

## 不可重复读

- 在一个事务内多次读取同一个数据集合，读取到的数据不一致

## 幻读

- **MYSQL中将不可重复读定义为幻读**，在RR隔离级别下使用NKL可以避免不可重复读与幻读