# bin log

- 命名`mysql-bin.xxx`
- 在MySQL5.1之前，所有的binlog都是基于SQL语句级别的。但是应用这种格式的binlog进行数据恢复时，如果SQL语句带有rand或uuid等函数，可能导致恢复出来的数据与原始数据不一致。因此从5.1版本开始，MySQL引入了binlog_format参数，该参数有三种可选值：statement、row和mixed：
  - statement就是之前的格式，基于SQL语句来记录
  - row记录的则是行的更改情况，可以避免之前提到的数据不一致的问题
  - 但是row格式有一个不好的地方就是当修改的行数很多时，生成的binlog占用很大的空间，占用大量空间的同时还会耗费大量IO资源，因此MySQL又提供了一种折中的方案——mixed。在mixed模式下，MySQL默认仍然采用statement格式进行记录，但是一旦它判断可能会有数据不一致的情况发生，则会采用row格式来记录
- `show variables like 'binlog_format'`查看日志格式
- `show master logs`查看日志列表
- `show binlog events in 'mysql-bin.xxx'` 查看日志内容
- binlog的默认是保持时间由参数expire_logs_days配置，也就是说对于非活动的日志文件，在生成时间超过expire_logs_days配置的天数之后，会被自动删除
- 落盘时机
  - Master Thread 每秒一次执行刷新Innodb_log_buffer到重做日志文件
  - 每个事务提交时会将重做日志刷新到重做日志文件
  - 当重做日志缓存可用空间 少于一半时，重做日志缓存被刷新到重做日志文件
- redo log包括两部分：一是内存中的日志缓冲(redo log buffer)，该部分日志是易失性的；二是磁盘上的重做日志文件(redo log file)，该部分日志是持久的。
- 在概念上，innodb通过**force log at commit**机制实现事务的持久性，即在事务提交的时候，必须先将该事务的所有事务日志写入到磁盘上的redo log file和undo log file中进行持久化
- 调用fsync()的作用就是将OS buffer中的日志刷到磁盘上的log file中

## 双一配置

- 在主从复制结构中，要保证事务的持久性和一致性，需要对日志相关变量设置为如下：

  - **如果启用了二进制日志，则设置sync_binlog=1，即每提交一次事务同步写到磁盘中。**
  - **总是设置innodb_flush_log_at_trx_commit=1，即每提交一次事务都写到磁盘中。**

  上述两项变量的设置保证了：每次提交事务都写入二进制日志和事务日志，并在提交时将它们刷新到磁盘中

- 更好的插入数据的做法是将innodb_flush_log_at_trx_commit值设置为1，然后修改存储过程，将每次循环都提交修改为只提交一次，这样既能保证数据的一致性，也能提升性能

# redo log

- 命名`ib_logfile`
- 默认情况下，每个InnoDB引擎至少有一个重做日志组，每个组下至少有两个重做日志文件，例如上文提到的iblogfile0和iblogfile1。重做日志组中的每个日志文件大小一致且循环写入，也就是说先写iblogfile0，写满了之后写iblogfile1，一旦iblogfile1也写满了，则继续写iblogfile0。显然，如果没有任何保护措施，这种机制会导致之前写入ib_logfile0的内容被覆盖。因此一旦redo log写满，MySQL将不得不停下所有更新操作来刷脏页
- 目前好像并没有什么办法可以以人类可以理解的方式查看redo log，原因在于与binlog记录的是逻辑日志不同，redo log记录的是对数据页更改的物理日志
- 重做日志是在事务开始之后逐步写入重做日志文件，而不一定是事务提交才写入重做日志缓存，原因就是，重做日志有一个缓存区Innodb_log_buffer，Innodb_log_buffer的默认大小为8M(这里设置的16M),Innodb存储引擎先将重做日志写入innodb_log_buffer中
- 即使某个事务还没有提交，Innodb存储引擎仍然每秒会将重做日志缓存刷新到重做日志文件。这一点是必须要知道的，因为这可以很好地解释再大的事务的提交（commit）的时间也是很短暂的

## 日志块

- innodb存储引擎中，redo log以块为单位进行存储的，每个块占512字节，这称为redo log block。所以不管是log buffer中还是os buffer中以及redo log file on disk中，都是这样以512字节的块存储的
- 每个redo log block由3部分组成：**日志块头、日志块尾和日志主体**。其中日志块头占用12字节，日志块尾占用8字节，所以每个redo log block的日志主体部分只有512-12-8=492字节

# bin与redo比较

- redo log是保证事务的持久性的，是事务层面的，binlog作为还原的功能，是数据库层面的（当然也可以精确到事务层面的），虽然都有还原的意思，但是其保护数据的层次是不一样的
- MySQL通过两阶段提交过程来完成事务的一致性的，也即redo log和binlog的一致性的，理论上是先写redo log，再写binlog，两个日志都提交成功（刷入磁盘），事务才算真正的完成
- 二进制日志只在每次事务提交的时候一次性写入缓存中的日志"文件"。而redo log在数据准备修改前写入缓存中的redo log中，然后才对缓存中的数据执行修改操作；而且保证在发出事务提交指令时，先向缓存中的redo log写入日志，写入完成后才执行提交动作
- 因为二进制日志只在提交的时候一次性写入，所以二进制日志中的记录方式和提交顺序有关，且一次提交对应一次记录。而redo log中是记录的物理页的修改，redo log文件中同一个事务可能多次记录，最后一个提交的事务记录会覆盖所有未提交的事务记录。例如事务T1，可能在redo log中记录了 T1-1,T1- 2,T1-3，T1* 共4个操作，其中 T1* 表示最后提交时的日志记录，所以对应的数据页最终状态是 T1* 对应的操作结果。而且redo log是并发写入的，不同事务之间的不同版本的记录会穿插写入到redo log文件中，例如可能redo log的记录方式如下： T1-1,T1-2,T2-1,T2- 2,T2*,T1-3,T1* 
- 

# undo log

- innodb存储引擎对undo的管理采用段的方式。rollback segment称为回滚段，每个回滚段中有1024个undo log segment

- undo log默认存放在共享表空间中，命名`ibdatax`。如果开启了 innodb_file_per_table ，将放在每个表的.ibd文件中

- 保存了事务发生之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读
- 逻辑格式的日志，在执行undo的时候，仅仅是将数据从逻辑上恢复至事务之前的状态，而不是从物理页面上操作实现的，这一点是不同于redo log的
- 事务开始之前，将当前是的版本生成undo log，undo 也会产生 redo 来保证undo log的可靠性
- 当事务提交之后，undo log并不能立马被删除，而是放入待清理的链表，由purge线程判断是否由其他事务在使用undo段中表的上一个事务之前的版本信息，决定是否可以清理undo log的日志空间

- 默认情况下undo文件是保持在共享表空间的，也即ibdatafile文件中，当数据库中发生一些大的事务性操作的时候，要生成大量的undo信息，全部保存在共享表空间中的

# 统一理论

- 事务的ACID是通过InnoDB日志和锁来保证。事务的隔离性是通过数据库锁的机制实现的，持久性通过redo log（重做日志）来实现，原子性和一致性通过Undo log来实现。UndoLog的原理很简单，为了满足事务的原子性，在操作任何数据之前，首先将数据备份到一个地方（这个存储数据备份的地方称为UndoLog）。然后进行数据的修改。如果出现了错误或者用户执行了ROLLBACK语句，系统可以利用Undo Log中的备份将数据恢复到事务开始之前的状态。 和Undo Log相反，RedoLog记录的是新数据的备份。在事务提交前，只要将RedoLog持久化即可，不需要将数据持久化。当系统崩溃时，虽然数据没有持久化，但是RedoLog已经持久化。系统可以根据RedoLog的内容，将所有数据恢复到最新的状态

## redo log

> InnoDB引擎独有，相当于备忘录

- WAL技术，Write Ahead Logging，先写日志，再写磁盘。即当有一条记录需要更新的时候，InnoDB引擎就会先把记录写到redo log里面，并更新内存，这个时候更新就算完成了。同时，InnoDB引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做
- redo log大小固定，循环写
- 双指针 check point、write point
  - checkpoint，当前要擦除的位置
  - write point，当前记录位置
  - write point 和 checkpoint 之间的是 “ 备忘录 ” 上还空着的部分，可以用来记录新的操作。如果 write point追上 checkpoint ，表示 “ 备忘录” 满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把check point 推进一下
- crash-safe：有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为**crash-safe**

## bin log

> Server层日志，归档日志，没有crash-safe功能

- binlog有三种记录模式，statement格式的话是记sql语句； row格式会记录行的内容，记两条，更新前和更新后都有；mixed格式MySQL默认仍然采用statement格式进行记录，但是一旦它判断可能会有数据不一致的情况发生，则会采用row格式来记录

## redo log与bin log区别

1. redo log是InnoDB引擎特有的；binlog是MySQL的Server层实现的，所有引擎都可以使用
2. redo log是物理日志，记录的是“在某个数据页上做了什么修改”；binlog是逻辑日志，记录的是这个语句的原始逻辑，比如“给ID=2这一行的c字段加1 ”
3. redo log是循环写的，空间固定会用完；binlog是可以追加写入的。“追加写”是指binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志

## 操作顺序

1. 搜索，如果数据不在内存，将其读入内存
2. 调用引擎接口更新数据，保存到内存中，同时提交记录到redolog，此时redolog状态为prepare（第一阶段提交）
3. 执行器生成该操作的binlog，将binlog写入磁盘
4. 执行器调用引擎接口提交事务，此时redolog状态为commit，更新完毕（第二阶段提交）

## 两阶段提交

> redolog的两阶段提交目的是为了让两份日志逻辑保持一致

- 由于redo log和binlog是两个独立的逻辑，如果不用两阶段提交，要么就是先写完redo log再写binlog，或者采用反过来的顺序，都会造成数据的不一致
  - 先写redo log，bin log失效，使用bin log备份恢复时缺失事务
  - 先写bin log，redo log失效，使用bin log备份恢复时多余事务

## 参数

- innodb_flush_log_at_trx_commit 这个参数设置成 1 的时候，表示每次事务的 redo log 都直接持久化到磁盘
- sync_binlog 这个参数设置成 1 的时候，表示每次事务的 binlog 都持久化到磁盘