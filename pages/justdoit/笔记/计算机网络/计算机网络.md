# 概述

## 协议三要素

- **语法**，就是这一段内容要符合一定的规则和格式。例如，括号要成对，结束要使用分号等。
- **语义**，就是这一段内容要代表某种意义。例如数字减去数字是有意义的，数字减去文本一般来说就没有意义。
- **顺序**，就是先干啥，后干啥。例如，可以先加上某个数值，然后再减去某个数值

## OSI七层网络协议

- 应用层：HTTP等统一协议规范

- 表示层：信息的语法语义以及他们的关联，翻译，包装信息的“跨平台”

- 会话层：不同机器上用户之间建立及管理会话，使得程序自动收发包及自动寻址
  - SSL、TLS、LDAP、RPC

- **传输层**：分割数据，保证数据质量
  - TCP/UDP协议

- 网络层：控制子网的运行，如逻辑编址，分组传输，路由选择
  - IP/IPV6协议

- 数据链路层：物理寻址，数据格式化、错误检测与纠正（交换机）
  - ARP，RARP地址解析协议
  - PPTP、L2TP、L2F、ATMP隧道协议

- 物理层：物理设备的标准，数模转换，传输比特流（网卡、网线）

## 五层网络协议

> 只要是在网络上跑的包，都是完整的。可以有下层没上层，绝对不可能有上层没下层

- 应用层
- 传输层
- 网络层
- 链路层
- 物理层

## TCP/IP协议

> OSI协议的实现

- 应用层
- 传输层
- 网络层
- 链路层

# TCP协议

## 简介

- 面向连接的，可靠的，基于字节流的传输层通信协议
- 将应用层的数据流分割成报文段并发送给目标节点的TCP层
- 数据包都有序号，对方确认则发送ACK确认，未收到则重传
- 使用校验和来检验数据在传输过程中是否有误

## 三次握手

> ack的值永远是对回复的消息的序号`seq+1`

1. 第一次握手时，客户端发送SYN包（`syn=j`）到服务器并进入`SYN_SEND`状态（服务器被动创建连接，客户端主动创建连接），“你听到了吗”
2. 第二次握手，服务器收到SYN包，确认客户端的SYN（`ack=j+1`），同时自己也发送一个SYN包（`syn=k`），即SYN+ACK包，此时服务器进入SYN_RECV状态，“我听到了，你听得到我说话吗”
3. 第三次握手，客户端收到服务器发来的SYN+ACK包，向服务器发起确认包ACK（`ack=k+1`），此包发送完毕，客户端和服务器端进入`ESTABLISHED`状态，完成三次握手，“听得到，现在可以开始说话了”
4. 三次握手的必要性，初始化`SequenceNumber`，后续使用

## SYN超时

- 首次握手的隐患，SYN超时——Server收到Client的SYN，回复SYN-ACK的时候未收到ACK确认，Server会不断重试直到超时。
- 针对`SYNFlood`（`SYNFlood溢出攻击`）的防护措施——SYN队列满之后，通过`tcp-syncookies`参数回发`SYNCookie`，若为正常连接则Client会回发`SYNCookie`，直接建立连接

## 保活机制

- 向对方发送保活探测报文，如果未收到响应则继续发送
- 尝试次数达到保活探测数仍未收到响应则中断连接

## 四次挥手

1. Client发送一个FIN报文（序号为u）用来关闭Client到Server的数据传输，Client进入FIN_WAIT1状态
2. Server收到FIN后，发送ACK，序号为v，确认序号为u+1，Server进入CLOSE_WAIT状态
3. Server发送一个FIN，序号为w，确认序号仍为u+1，可以继续向Client发送收尾数据，Server进入LAST_ACK状态
4. Client收到FIN之后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，序号为u+1，确认序号为w+1
5. TIME_WAIT状态的必要性：确保有足够的时间让对方收到ACK包；避免新旧连接混淆
6. 为什么需要四次挥手：TCP是全双工的协议，发送方与接收方都需要FIN报文以及ACK报文
7. 服务器出现大量CLOSE_WAIT状态的原因：客户端关闭连接，服务器忙于处理其它请求，没有及时关闭连接

## 滑动窗口

- RTT，发送一个数据包到收到对应ACK的耗时
- RTO，重传时间间隔，经过RTT动态计算
- TCP使用滑动窗口做**流量控制**与**乱序重排**
  - 保证TCP的可靠性
  - 保证TCP的流控特性

- `AdvertisedWindow = MaxRcvBuffer - (LastByteRcvd-LastByteRead)`接收方的剩余处理能力
- `EffectiveWindow = AdvertisedWindow-(LastByteSent-LastByteAcked)`发送方剩余发送能力

# UDP协议

## 报文结构

- Source Port
- Destination Port
- Length
- Check Sum
- Data Octets（Optional）

## 特点

- 面向无连接
- 不维护状态，支持同时向多个客户传输相同的消息
- 数据报头短，额外开销较小
- 吞吐量只受限于数据生成速率，传输速率以及机器性能
- 尽最大努力交付，不提供可靠交付，不需要维护复杂的连接状态表
- 面向报文，不对应用程序提交的报文信息进行拆分或者合并（UDP对应用程序发放的数据添加头部之后直接发送）

# HTTP

> 超文本传输协议

- 支持客户‘服务器模式（请求响应模型）
- 可以传输任意类型的数据
- 无连接
- 无状态

## 请求结构

- 请求报文
  - 请求行（请求方法 请求路径 协议版本）
  - 请求头（键值对）
- 请求正文（POST请求使用），即使没有请求正文，回车换行仍然是必须的

## 响应结构

- 响应报文
  - 状态行（状态码 状态码描述 协议版本）
  - 响应头
- 响应正文

## 常用状态码

- 200，正常
- 400，客户端请求错误
- 401，请求未授权
- 403，拒绝提供服务
- 404，资源不存在
- 500，服务器内部错误
- 503 Server Unavailable：服务器当前时间不能处理客户端请求，一段时间之后可能恢复（服务器正在启动中或者连接池已满）

## Get与Post

- HTTP报文层面：Get将请求信息放在URL，POST放在报文体中
- 数据库层面：Get符合幂等性和安全性
- 缓存：GET请求可以被缓存，被储存

## Cookie与Session

### Cookie

- Cookie是服务器发送给客户端的特殊信息，以文本形式存储在客户端
- 客户端再次请求的时候，会把Cookie回发
- 服务器收到之后，会解析Cookie生成与客户端相对应的内容

### Session

- 服务器的状态保持机制
- 解析客户端请求并操作`sessionId`，按需保存状态信息
- 实现方式
  - 使用Cookie实现，`JSESSIONID`
  - 使用URL回写，服务器发送给浏览器页面的所有URL都带有`JSESSIONID`

## HTTPS

- HTTP：HTTP+TCP+IP

- HTTPS：HTTP+**SSL or TLS**+TCP+IP

### SSL&TLS

> Security Socket Layer 安全套接字层，SSL3.0之后改为TLS

- 为网络通信提供安全以及数据完整性的一种安全协议
- 是操作系统对外提供的API
- 采用**身份验证**和**数据加密**保证网络通信的安全和数据的完整性
- 加密方式
  - 对称加密
  - 非对称加密
  - 哈希算法
  - 数字签名

### 数据传输过程

1. 浏览器将支持的加密算法信息发送给服务器
2. 服务器选择一套浏览器支持的加密算法，以证书的形式回发浏览器
3. 浏览器检验证书合法性，并结合证书公钥加密信息发送给服务器
4. 服务器使用私钥解密信息，验证哈希，加密响应消息回发浏览器
5. 浏览器解密响应信息，并对消息进行验真，之后进行加密数据交互

### HTTPS安全隐患

- 浏览器默认填充http协议，请求需要进行跳转，有被劫持的风险
- 可以使用HSTS（HTTP Strict Transport Security）优化

# Socket

> Socket是TCP/IP协议的抽象，是操作系统对外开放的接口，与TCP/IP协议没有必然的联系

- `IP:port`
- 服务器：`socket->bind->listen->accept->recv->close`
- 客户端：`socket->connect->send->close`