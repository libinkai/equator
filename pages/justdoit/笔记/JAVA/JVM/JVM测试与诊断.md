# 基准测试

# 检测与诊断（命令行）

## jps

- 它将打印所有正在运行的 Java 进程的相关信息，在默认情况下，`jps`的输出信息包括 Java 进程的进程 ID 以及主类名

- 参数
  - `-l`将打印模块名以及包名
  - `-v`将打印传递给 Java 虚拟机的参数（如`-XX:+UnlockExperimentalVMOptions -XX:+UseZGC`）
  - `-m`将打印传递给主类的参数

- 需要注意的是，如果某 Java 进程关闭了默认开启的`UsePerfData`参数（即使用参数`-XX:-UsePerfData`），那么`jps`命令（以及下面介绍的`jstat`）将无法探知该 Java 进程

## jstat

- 打印目标 Java 进程的性能数据

- `jstat -outputOptions [-t] [-hlines] VMID [interval [count]]`

- 子命令
  - `-class`将打印类加载相关的数据
  - `-compiler`和`-printcompilation`将打印即时编译相关的数据
  - 以`-gc`为前缀的子命令，它们将打印垃圾回收相关的数据

- 参数
  - -t 在每行数据之前打印目标 Java 进程的启动时间，来获得多组 OU 最小值

- gc结果说明
  - S0C    S1C    S0U    S1U （survivor）
  - EC EU（Eden）
  - OC OU（Old）
  - MC MU（方法区）
  - CCSC   CCSU（压缩类空间）
  - YGC 从应用程序启动到采样时发生 Young GC 的次数 
  - YGCT 从应用程序启动到采样时 Young GC 所用的时间（秒） 
  - FGC 从应用程序启动到采样时发生 Full GC 的次数
  - FGCT 从应用程序启动到采样时 Full GC 所用的时间（秒）
  - CGC CGCT 并发
  - GCT 从应用程序启动到采样时用于垃圾回收的总时间（秒）

- `jstat`还可以用来判断是否出现内存泄漏。在长时间运行的 Java 程序中，我们可以运行`jstat`命令连续获取多行性能数据，并取这几行数据中 OU 列（即已占用的老年代内存）的最小值。然后，我们每隔一段较长的时间重复一次上述操作，来获得多组 OU 最小值。如果这些值呈上涨趋势，则说明该 Java 程序的老年代内存已使用量在不断上涨，这意味着无法回收的对象在不断增加，因此很有可能存在内存泄漏。

## jmap

> 当出现内存泄漏，可以利用jmap进一步分析 Java 虚拟机堆中的对象

- 子命令
  - `-clstats`，该子命令将打印被加载类的信息。
  - `-finalizerinfo`，该子命令将打印所有待 finalize 的对象。
  - `-histo`，该子命令将统计各个类的实例数目以及占用内存，并按照内存使用量从多至少的顺序排列。此外，`-histo:live`只统计堆中的存活对象。
  - `-dump`，该子命令将导出 Java 虚拟机堆的快照。同样，`-dump:live`只保存堆中的存活对象。

- 由于`jmap`将访问堆中的所有对象，为了保证在此过程中不被应用线程干扰，`jmap`需要借助安全点机制，让所有线程停留在不改变堆中数据的状态。也就是说，由`jmap`导出的堆快照必定是安全点位置的。这可能导致基于该堆快照的分析结果存在偏差。举个例子，假设在编译生成的机器码中，某些对象的生命周期在两个安全点之间，那么`:live`选项将无法探知到这些对象。

## jinfo

- 查看目标 Java 进程的参数（配置信息），如传递给 Java 虚拟机的`-X`（即输出中的 jvm_args）、`-XX`参数（即输出中的 VM Flags），以及可在 Java 层面通过`System.getProperty`获取的`-D`参数（即输出中的 System Properties）

## jstack

- 打印目标 Java 进程中各个线程的栈轨迹，以及这些线程所持有的锁

## jcmd

- 替代前面除了`jstat`之外的所有命令。具体的替换规则你可以参考下表

## Linux指令

### top

- `top [-] [d delay] [q] [c] [S] [s] [i] [n] [b]`
  - d : 改变显示的更新速度，或是在交谈式指令列( interactive command)按 s
  - q : 没有任何延迟的显示速度，如果使用者是有 superuser 的权限，则 top 将会以最高的优先序执行
  - c : 切换显示模式，共有两种模式，一是只显示执行档的名称，另一种是显示完整的路径与名称S : 累积模式，会将己完成或消失的子行程 ( dead child process ) 的 CPU time 累积起来
  - s : 安全模式，将交谈式指令取消, 避免潜在的危机
  - i : 不显示任何闲置 (idle) 或无用 (zombie) 的行程
  - n : 更新的次数，完成后将会退出 top
  - b : 批次档模式，搭配 "n" 参数一起使用，可以用来将 top 的结果输出到档案内

- 输出结果解析

  - 第一行，任务队列信息

    - 当前系统时间
    - 系统运行时间
    - 当前登录用户数
    - 系统的平均负载数，表示 1分钟、5分钟、15分钟到现在的平均数

  - 第二行，进程统计信息

    - 系统当前总进程总数
    - 正在运行的进程数
    - 睡眠进程数
    - 停止进程数
    - 僵尸进程数

  - 第三行，CPU统计信息

    - us 用户空间CPU占用率
    - sy 内核空间CPU占用率
    - ni 用户进程空间改变过优先级的进程CPU的占用率
    - id 空闲CPU占有率
    - wa 等待输入输出的CPU时间百分比
    - hi  硬件中断请求
    - si 软件中断请求
    - st 分配给运行在其它虚拟机上的任务的实际 CPU时间

  - 第四行，内存状态

    - total 物理内存总量
    - used  已使用的内存
    - free 空闲内存
    - buffers 内核缓存使用23M

  - 进程信息

    **PID**  （进程id）
     **USER**  （进程所有者的用户名）
     **PR**  （进程优先级）
     **NI**  （nice值。负值表示高优先级，正值表示低优先级）
     **VIRT**  （进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES）
     **RES**  （进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA）
     **SHR**  （共享内存大小，单位kb）
     **S**  （进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程）
     **%CPU**  （上次更新到现在的CPU时间占用百分比）
     **%MEM**  （进程使用的物理内存百分比）
     **TIME+**  （进程使用的CPU时间总计，单位1/100秒）
     **COMMAND**  （进程名称[命令名/命令行]）

## JMC

