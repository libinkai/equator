# final

- 被final修饰的基本类型变量无法被修改，被final修饰的引用变量无法被重新引用，但是其成员变量（属性）可以被修改
- Java函数传递参数时，基本类型传递的是值得拷贝，引用类型传递的是引用的拷贝。引用的拷贝被重新指向，不会影响原来的对象，但是利用引用进行对属性的修改，会反映到原来的对象上

# 字符串

- 在 JDK 8 中，字符串拼接操作会自动被 javac 转换为 StringBuilder 操作，而在 JDK 9 里面则是因为 Java 9 为了更加统一字符串操作优化，提供了 StringConcatFactory，作 为一个统一的入口。javac 自动生成的代码，虽然未必是最优化的，但普通场景也足够了，你可 以酌情选择
- String 在 Java 6 以后提供了 intern() 方法，目的是提示 JVM 把相应字符串缓存起来，以备重 复使用。在我们创建字符串对象并调用 intern() 方法的时候，如果已经有缓存的字符串，就会 返回缓存里的实例，否则将其缓存起来。一般来说，JVM 会将所有的类似“abc”这样的文本字 符串，或者字符串常量之类缓存起来。

# int与Integer

- Java 语言虽然号称一切都是对象，但原始 数据类型是例外
- 。构建 Integer 对象的传统方式是直接调 用构造器，直接 new 一个对象。但是根据实践，我们发现大部分数据操作都是集中在有限的、 较小的数值范围，因而，在 Java 5 中新增了静态工厂方法 valueOf，在调用它的时候会利用一 个缓存机制，带来了明显的性能改进。按照 Javadoc，这个值默认缓存是 -128 到 127 之间
- 自动装箱实际上算是一种语法糖。什么是语法糖？可以简单理解为 Java 平台为我们自动进行了 一些转换，保证不同的写法在运行时等价，它们发生在编译阶段，也就是生成的字节码是一致 的
- javac 替我们自动把装箱转换为 Integer.valueOf()，把拆箱替换为 Integer.intValue()

# 接口与抽象类

## 接口

- 抽象方法的集合
- JDK8以后新增默认方法

- 属性均为public static final
- 没有非静态方法实现，即要么是抽象方法，要么是静态方法

## 抽象类

- 为了代码的重用

# 重载与重写

## 重载

- 相同名字的方法，但是参数不同

## 重写

- 父子类种相同名字和参数的方法，不同的实现